Imports System
Imports System.IO
Imports System.IO.Disk
Imports System.Threading

Module FloppyDisk
    Pointer Dim FloppyA360 as DiskInfo
    Pointer Dim FloppyA720 as DiskInfo
    Pointer Dim FloppyA1200 as DiskInfo
    Pointer Dim FloppyA1440 as DiskInfo
    Pointer Dim FloppyB360 as DiskInfo
    Pointer Dim FloppyB720 as DiskInfo
    Pointer Dim FloppyB1200 as DiskInfo
    Pointer Dim FloppyB1440 as DiskInfo
    Dim Buffer as Block512B
    Dim Motor0Counter as UInt16
    Dim Motor0Status as UInt16
    Dim Motor1Counter as UInt16
    Dim Motor1Status as UInt16
    Dim DMAStatus as UInt16
    Dim DriveSelected as UInt16
    Dim ResetStatus as UInt16

    Dim Drive0Busy as UInt16
    Dim Drive1Busy as UInt16
    Dim ControllerBusy as UInt16
    Dim ControllerDMA as UInt16
    Dim ControllerDIO as UInt16
    Dim ControllerRQM as UInt16

    Dim CurrentCylinder as UInt16
    Dim StatusRegister0 as UInt16

    Public Sub Initialize
       Dim t as Thread
       t = Thread.RequestNew()
       ' Inicia a tarefa Main com 2 KiB de Pilha
       Thread.Start t, 2, AddressOf(Main)
    End

    ' Tarefa responsÃ¡vel por monitorar o Controlador de disquete
    Sub Main()
        Dim i as UInt16
        FloppyA360  = Disk.RegisterNew("Floppy0_360", 0, 40, 2, 9, 512)
        FloppyA360.ReadBlock = AddressOf(ReadBlock)
        FloppyA360.WriteBlock = AddressOf(WriteBlock)
        FloppyA720  = Disk.RegisterNew("Floppy0_720", 0, 40, 2, 18, 512)
        FloppyA720.ReadBlock = AddressOf(ReadBlock)
        FloppyA720.WriteBlock = AddressOf(WriteBlock)
        FloppyA1200 = Disk.RegisterNew("Floppy0_1200", 0, 80, 2, 15, 512)
        FloppyA1200.ReadBlock = AddressOf(ReadBlock)
        FloppyA1200.WriteBlock = AddressOf(WriteBlock)
        FloppyA1440 = Disk.RegisterNew("Floppy0_1440", 0, 80, 2, 18, 512)
        FloppyA1440.ReadBlock = AddressOf(ReadBlock)
        FloppyA1440.WriteBlock = AddressOf(WriteBlock)
        FloppyB360  = Disk.RegisterNew("Floppy1_360", 1, 40, 2, 9, 512)
        FloppyB360.ReadBlock = AddressOf(ReadBlock)
        FloppyB360.WriteBlock = AddressOf(WriteBlock)
        FloppyB720  = Disk.RegisterNew("Floppy1_720", 1, 40, 2, 18, 512)
        FloppyB720.ReadBlock = AddressOf(ReadBlock)
        FloppyB720.WriteBlock = AddressOf(WriteBlock)
        FloppyB1200 = Disk.RegisterNew("Floppy1_1200", 1, 80, 2, 15, 512)
        FloppyB1200.ReadBlock = AddressOf(ReadBlock)
        FloppyB1200.WriteBlock = AddressOf(WriteBlock)
        FloppyB1440 = Disk.RegisterNew("Floppy1_1440", 1, 80, 2, 18, 512)
        FloppyB1440.ReadBlock = AddressOf(ReadBlock)
        FloppyB1440.WriteBlock = AddressOf(WriteBlock)
        IO.RegisterHandler 14, AddressOf(FloppyInt)
        InitDMA
        Reset
        While 1 
            If Motor0Counter > 0 Then
                Motor0Counter--
                If Motor0Counter == 0 Then
                    StopMotor 0
                End
            End
            If Motor1Counter > 0 Then
                Motor1Counter--
                If Motor1Counter == 0 Then
                    StopMotor 1
                End
            End
            Thread.Sleep 1000
        End
    End

    Dim IrqStatus as UInt16

    Sub FloppyInt() Handles Interrupt
        asm "cli"
        IrqStatus = 1
        asm "mov al, 0x20"
        asm "out 0x20, al"
        asm "sti"
    End



    Sub Calibrate(d as UInt16)
        Dim i as UInt16
        StartMotor d
        For i = 1 to 10
            WriteCmd 7
            WriteCmd d
            WaitIRQ
            CheckInterrupt
            If CurrentCylinder == 0 Then
                StopMotor d
                Return 
            End
        End
        StopMotor d
        Throw NoAnswerError
    End

    Sub InitDMA
        IO.OutputByte 0xa, 0x6
        IO.OutputByte 0xd8, 0x6
        IO.OutputByte 0x4, @Buffer and 0xf
        IO.OutputByte 0x4, ((#Buffer and 0xf) shl 4) or ((@Buffer shr 4) and 0xf)
        IO.OutputByte 0x8, 0xff
        IO.OutputByte 0x5, 0xff
        IO.OutputByte 0x5, 0x1
        IO.OutputByte 0x80, #Buffer shr 4
        IO.OutputByte 0xa, 0x2
    End

    Sub WriteDOR
        IO.OutputByte 0x3f2, ((Motor0Status and 1) * 16) + ((Motor1Status and 1) * 32) + ((ResetStatus and 1) * 4) + ((DMAStatus and 1) * 8) + (DriveSelected and 3)
    End

    Sub ReadMSR
        Dim tmp as UInt8
        tmp = IO.InputByte(0x3f4)
        Drive0Busy = tmp and 1
        Drive1Busy = tmp and 2
        ControllerBusy = tmp and 16
        ControllerDMA = tmp and 32
        ControllerDIO = tmp and 64
        ControllerRQM = tmp and 128
    End

    Sub WriteCtrl(value as UInt8)
        IO.OutputByte 0x3f7, value
    End

    Sub WriteFIFO(value as UInt8)
        IO.OutputByte 0x3f5, value
    End

    Function ReadFIFO() as UInt8
        Return IO.InputByte(0x3f5)
    End

    Sub WriteCmd(cmd as UInt8)
        Dim i as UInt16
        For i = 1 to 500
            ReadMSR
            If ControllerRQM Then
                WriteFIFO cmd
                Return
            End
        End
    End

    Function ReadData() as UInt8
        Dim i as UInt16
        For i = 1 to 500
            ReadMSR
            If ControllerRQM Then
                Return ReadFIFO()
            End
        End
        Return 0
    End

    Sub StopMotor(motor as UInt16)
        If motor == 0 Then 
            Motor0Status = 0
        End
        If motor == 1 Then 
            Motor1Status = 0
        End
        WriteDOR
    End

    Sub StartMotor(motor as UInt16)
        Dim wait as UInt16
        wait = 0
        If (motor == 0) AndAlso (Motor0Status == 0) Then wait = 1
        If (motor == 1) AndAlso (Motor1Status == 0) Then wait = 1
        If motor == 0 Then 
            Motor0Counter = 5
            Motor0Status = 1
        End
        If motor == 1 Then 
            Motor1Counter = 5
            Motor1Status = 1
        End
        WriteDOR
        If wait Then Thread.Sleep 400
    End

    Sub Reset
        Dim i as UInt16
        Disable
        Thread.Sleep 400
        ReadMSR
        Enable
        WaitIRQ
        For i = 0 to 3
            CheckInterrupt
        End
        WriteCtrl 0
        ConfigDrive 1, 3, 16, 240
        Try
            Calibrate 0
        Catch Error
        End
        Try
            Calibrate 1
        Catch Error
        End
    End

    Sub Disable
        DMAStatus = 0
        ResetStatus = 0
        Motor0Counter = 0
        Motor1Counter = 0
        Motor0Status = 0
        Motor1Status = 0
        WriteDOR
    End

    Sub Enable
        DMAStatus = 1
        ResetStatus = 1
        WriteDOR
    End

    Sub DMARead
        IO.OutputByte 0xa, 0x6
        IO.OutputByte 0xb, 0x56
        IO.OutputByte 0xa, 0x2
    End

    Sub DMAWrite
        IO.OutputByte 0xa, 0x6
        IO.OutputByte 0xb, 0x5a
        IO.OutputByte 0xa, 0x2
    End

    Sub WaitIRQ
        While IrqStatus == 0 Thread.Yield
        IrqStatus = 0
    End

    Sub ConfigDrive(dma as Uint16, stepRate as UInt16, unloadTime as UInt16, loadTime as UInt16)
        WriteCmd 3
        WriteCmd (unloadTime and 0xf) or ((stepRate and 0xf) shl 4)
        If dma Then dma = 1
        WriteCmd (loadTime shl 1) or dma
    End

    Sub CheckInterrupt
        WriteCmd 8
        StatusRegister0 = ReadData() ' Status Register
        CurrentCylinder = ReadData() ' Current Cylinder
    End

    Sub Seek(disk as DiskInfo, cylinder as UInt16, head as UInt16)
        Dim i as UInt16
        For i = 1 to 10
            WriteCmd 0xf
            WriteCmd ((head shl 2) or DriveSelected)
            WriteCmd cylinder

            WaitIRQ

            CheckInterrupt
            If CurrentCylinder == cylinder Then Return
        End
        Throw NoAnswerError
    End

    Sub ReadBlock(disk as DiskInfo, block as PtrByteArray, positionLow as UInt16, positionHigh as UInt16)
        Dim chs as CHSAddress
        Disk.ConvertToCHS chs, disk, positionLow, positionHigh
        If disk.Sectors == 18 Then
            WriteCmd 27 ' 3 1/2
        Else
            WriteCmd 32 ' 5 1/4
        End
        Seek disk, chs.Cylinder, chs.Head
        DMARead
        WriteCmd 0x80 or 0x40 or 0x20 or 2
        WriteCmd (chs.Head shl 2) or (DriveSelected)
        WriteCmd chs.Cylinder
        WriteCmd chs.Head
        WriteCmd chs.Sector
        WriteCmd 2 ' 512 Bytes
        WriteCmd chs.Cylinder
        If (chs.Sector + 1) >= disk.Sectors Then
            WriteCmd disk.Sectors
        Else
            WriteCmd chs.Sector + 1
        End
        If disk.Sectors == 18 Then
            WriteCmd 27 ' 3 1/2
        Else
            WriteCmd 32 ' 5 1/4
        End
        WriteCmd 0xff
        WaitIRQ
        ReadData
        ReadData
        ReadData
        ReadData
        ReadData
        ReadData
        ReadData
        CheckInterrupt
        Memory.Copy block, Buffer, 512
    End

    Sub WriteBlock(disk as DiskInfo, block as PtrByteArray, positionLow as UInt16, positionHigh as UInt16)
        Throw NotImplementedError
    End
End